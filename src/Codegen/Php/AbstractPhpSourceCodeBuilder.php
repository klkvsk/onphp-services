<?php
/**
 * @author Mikhail Kulakovskiy <m@klkvsk.ru>
 * @date 2015-12-03
 */

namespace OnPhp\Services\Codegen\Php;

use \OnPhp\Services\Codegen\AbstractSourceCodeBuilder;
use \OnPhp\Services\Codegen\SourceCodeClassReference;
use \OnPhp\Services\Codegen\SourceCodeTypeReference;
use \OnPhp\Services\Meta\MetaProperty;

abstract class AbstractPhpSourceCodeBuilder extends AbstractSourceCodeBuilder
{

    protected $usedNamespaces = [];

    /**
     * @param $value
     * @return $this
     * @throws \WrongArgumentException
     */
    public function addValue($value)
    {
        if (is_array($value)) {
            $this->addArray(
                $value,
                array_keys($value) != range(0, count($value) - 1), // is assoc
                count($value) > 4 // max values until multiline
            );
        } else if ($value instanceof SourceCodeClassReference) {
            $value = PhpSourceCodeClassReference::wrap($value);
            $this->add($value->getSelfName());

        } else if ($value instanceof PhpSourceCodeTypeReference) {
            $this->add($value->toString());

        } else if (is_string($value)) {
            $this->addString($value);

        } else if (is_bool($value)) {
            $this->add($value ? 'true' : 'false');

        } else if (is_null($value)) {
            $this->add('null');

        } else if (is_numeric($value)) {
            $this->add($value);

        } else {
            throw new \WrongArgumentException('wtf should i do with it?');
        }
        return $this;
    }

    protected function addString($string)
    {
        return $this->add('\'' . addslashes($string) . '\'');
    }

    protected function addArray(array $array, $assoc = false, $multiline = false)
    {
        $this->add('[');
        if ($multiline) {
            $this->indent()->newLine();
        }
        $length = count($array);
        $num = 0;
        foreach ($array as $key => $value) {
            $num++;
            if ($assoc) {
                $this->addString($key)->add(' => ');
            }
            $this->addValue($value);
            if ($num < $length) {
                $this->add(', ');
            }
            if ($multiline) {
                $this->newLine();
            }
        }
        if ($multiline) {
            $this->unindent()->newLine();
        }
        $this->add(']');

        return $this;
    }

    /**
     * @param $className
     * @return PhpSourceCodeClassReference
     */
    public function classRef($className)
    {
        if ($className instanceof SourceCodeClassReference) {
            return PhpSourceCodeClassReference::wrap($className);
        } else {
            return PhpSourceCodeClassReference::create($className);
        }
    }

    /**
     * @param $className
     * @return PhpSourceCodeTypeReference
     */
    public function typeRef($type)
    {
        if ($type instanceof SourceCodeTypeReference) {
            return PhpSourceCodeTypeReference::wrap($type);
        } else {
            return PhpSourceCodeTypeReference::create($type);
        }
    }

    public function addHeaderDocForAutogenerated()
    {
        return $this->doc([
            'This file is auto-generated',
            '/!\ DO NOT MODIFY /!\\',
            '',
            ['@nodiff', 'last modified', date('Y-m-d H:i:s')]
        ]);
    }

    public function addHeaderDocForGeneratedOnce()
    {
        return $this->doc([
            'This file is autogenerated only if it does not exist',
            'Feel free to modify it, your code would not be overwritten',
            '',
            ['@nodiff', 'created', date('Y-m-d H:i:s')]
        ]);
    }

    public function build()
    {
        $this
            ->clean()
            ->addLine('<?php')
            ->addHeaderDocForAutogenerated()
            ->newLine();
    }

    public function addPrimitiveDefinition(MetaProperty $property)
    {
        $type = $this->typeRef($property->getType());
        $primitiveName = $type->getPrimitiveName();
        $primitive = call_user_func([\Primitive::class, $primitiveName], $property->getName());
        $this
            ->add($this->classRef(\Primitive::class)->getStatic($type->getPrimitiveName()))
            ->addArguments([$property->getName()])
            ->indent()
            ->newLine();

        // set additional params
        if ($primitive instanceof \ComplexPrimitive) {
            $this->addLine('->setSingle()');
        }
        if ($primitive instanceof \PrimitiveForm) {
            $this->addLine('->ofProto(' . $this->classRef($type->getTypeName())->getStatic('entityProto()') . ')');
        }
        if ($primitive instanceof \IdentifiablePrimitive) {
            $this->addLine('->of(' . $this->classRef($type->getTypeName())->getSelfName() . ')');
        }
        // required or optional
        if ($property->isRequired()) {
            $this->addLine('->required()');
        } else {
            $this->addLine('->optional()');
        }
        // convert to ArrayOfPrimitive if it is array
        if ($type->isArray()) {
            $this->addLine('->arrayOf()');
        }

        $this->unindent();
        return $this;
    }

}